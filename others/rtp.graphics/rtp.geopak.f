        c----------------Drawing utility used by gcontr---------      subroutine draw(xx,yy,iflag)c       Used by gcontr.      x=xx      y=yy      call ctrans(x,y)	      ih=iflag/10      il=iflag-10*ih	      if(il.eq.6) go to 40      if(il.eq.1) then            call gvect(x,y,1)           return      endif      if(il.ge.4) go to 30* if  il=2 or 3	       call gvect(x,y,0)        call polop      return30    call gvect(x,y,1) !finish poly      call polcls40    return      end            subroutine ctrans(x,y)c     utility to transform x,y coordinates used by gcontrc     to user or plotter space      logical scale      common /limit/x1,x2,y1,y2,z1,z2,scale      common /coninf/nx,ny      common /devinf/devdi,devdj,devx,devy        x=x1 + (x2-x1)*(x-1.)/float(nx-1)        y=y1 + (y2-y1)*(y-1.)/float(ny-1)      end      c---------------GEOPAK setup routines-----------------------------            c---------------GEOPAK contouring call----------------------------      subroutine gcnr2v(z,npx,npy)      dimension z(npx,npy)      logical clset,scale      integer work      common /limit/x1,x2,y1,y2,z1,z2,scale      common /class/zcl(100),nrcl,clset,iop      common /wspace/work(5000)      common /ginfo/undef      common /coninf/nx,ny      save /class/,/wspace/,/ginfo/,/coninf/,/limit/      nx=npx      ny=npy      if(.not.scale) then            call gscale            call glimit(0.,1.,0.,1.,0.,0.)      endif           if(.not.clset) then            if(iop.eq.1) thenc      (percentiles-- not implemented)            else if(iop.eq.2) then              v1=vmin(z,npx*npy)              v2=vmax(z,npx*npy)              dz=(v2-v1)/float(nrcl+1)              do 3 i=1,nrcl3             zcl(i)=v1 + dz*float(i)              clset=.true.            endif      endif       call gcontr(z,npx,npx,npy,zcl,nrcl,undef,work)c     Now draw frame around viewport      call vframe      endc------------Start core contour routine--------------------------	subroutine gcontr(z,nrz,nx,ny,cv,ncv,zmax,bitmap)	real z(nrz,1),cv(1)	integer bitmap(1)	integer l1(4),l2(4),ij(2)	integer i1(2),i2(2),i3(6)	real xint(4)	real xy(2)	equivalence(l2(1),imax),(l2(2),jmax),(l2(3),imin),     *(l2(4),jmin)	equivalence(ij(1),i),(ij(2),j)	equivalence(xy(1),x),(xy(2),y)	data l1(3)/-1/,l1(4)/-1/	data i1/1,0/,i2/1,-1/,i3/1,0,0,1,1,0/	l1(1)=nx	l1(2)=ny	dmax=zmax	x=1.0	y=1.0	call draw(x,y,6)	icur=max0(1,min0(int(x),nx))	jcur=max0(1,min0(int(y),ny))     	call fill0(bitmap,2*nx*ny*ncv)     	ibkey=0 10   i=icur	j=jcur 20   imax=i	imin=-i	jmax=j	jmin=-j	idir=0 30   nxidir=idir+1	k=nxidir	if(nxidir.gt.3)nxidir=0 40   i=iabs(i)	j=iabs(j)	if(z(i,j).gt.dmax) go to 140	l=1 50   if (ij(l).ge.l1(l))go to 130	ii=i+i1(l)	jj=j+i1(3-l)	if(z(ii,jj).gt.dmax) go to 130	assign 100 to jump 60   ix=1	if(ij(3-l).eq.1) go to 80	ii=i-i1(3-l)	jj=j-i1(l)	if(z(ii,jj).gt.dmax) go to 70	ii=i+i2(l)	jj=j+i2(3-l)	if(z(ii,jj).lt.dmax) ix=0 70   if (ij(3-l).ge.l1(3-l)) go to 90 80   ii=i+i1(3-l)	jj=j+i1(l)	if (z(ii,jj).gt.dmax) go to 90	if (z(i+1,j+1).lt.dmax) go to jump,(100,280) 90   ix=ix+2	go to jump,(100,280)100   if (ix.eq.3) go to 130	if (ix+ibkey.eq.0) go to 130	ii=i+i1(l)	jj=j+i1(3-l)	z1=z(i,j)	z2=z(ii,jj)	do 120 icv=1,ncv	  if (iget(bitmap,2*(nx*(ny*(icv-1)+j-1)+i-1)+l).ne.0) go to 120	  if (cv(icv).le.amin1(z1,z2)) go to 110	  if (cv(icv).le.amax1(z1,z2)) go to 190 110    call mark1(bitmap,2*(nx*(ny*(icv-1)+j-1)+i-1)+l) 120  continue 130  l=l+1	if(l.le.2) go to 50 140  l=mod(idir,2)+1	ij(l)=isign(ij(l),l1(k)) 150  if(ij(l).ge.l1(k)) go to 170	ij(l)=ij(l)+1	if(ij(l).gt.l2(k)) go to 160	go to 40 160  l2(k)=ij(l)	idir=nxidir	go to 30 170  if(idir.eq.nxidir ) go to 180	nxidir=nxidir+1	ij(l)=l1(k)	k=nxidir	l=3-l	ij(l)=l2(k)	if(nxidir.gt.3) nxidir=0	go to 150 180  if(ibkey.ne.0) return	ibkey=1	go to 10 190  iedge=l	cval=cv(icv)	if(ix.ne.1) iedge=iedge+2	iflag=2+ibkey	xint(iedge)=(cval-z1)/(z2-z1) 200  xy(l)=float(ij(l)+xint(iedge))	xy(3-l)=float(ij(3-l))	call mark1(bitmap,2*(nx*(ny*(icv-1)+j-1)+i-1)+l)	call draw(x,y,iflag+10*icv)	if(iflag.lt.4) go to 210	icur=i	jcur=j	go to 20 210  ni=1	if(iedge.lt.3) go to 220	i=i-i3(iedge)	j=j-i3(iedge+2) 220  do 250 k=1,4	if(k.eq.iedge) go to 250	ii=i+i3(k)	jj=j+i3(k+1)	z1=z(ii,jj)	ii=i+i3(k+1)	jj=j+i3(k+2)	z2=z(ii,jj)	if(cval.le.amin1(z1,z2)) go to 250	if(cval.gt.amax1(z1,z2)) go to 250	if(k.eq.1) go to 230	if(k.ne.4) go to 240 230  zz=z1	z1=z2	z2=zz 240  xint(k)=(cval-z1)/(z2-z1)	ni=ni+1	ks=k 250  continue	if(ni.eq.2) go to 260	ks=5-iedge	if(xint(3).lt.xint(1)) go to 260	ks=3-iedge	if(ks.le.0) ks=ks+4 260  l=ks	iflag=1	assign 280 to jump	if(ks.lt.3) go to 270	i=i+i3(ks)	j=j+i3(ks+2)	l=ks-2 270  if(iget(bitmap,2*(nx*(ny*(icv-1)+j-1)+i-1)+l).eq.0) go to 60	iflag=5	go to 290 280  if(ix.ne.0)  iflag=4 290  iedge=ks+2	if(iedge.gt.4) iedge=iedge-4	xint(iedge)=xint(ks)	go to 200	end	c 		subroutine fill0(bitmap,n)	integer bitmap(1),n	data nbpw/31/	loop=n/nbpw	nblw=mod(n,nbpw)	if(loop.eq.0)goto 20  	do 10 i=1,loop	 bitmap(i)=010    continue20    if(nblw.ne.0)bitmap(loop+1)=mod(bitmap(loop+1),2**(nbpw-nblw))	return	endc	function iget(bitmap,n)	integer bitmap(1),n	data nbpw/31/	nword=(n-1)/nbpw	nbit=mod(n-1,nbpw)	iget=mod(bitmap(nword+1)/2**(nbpw-nbit-1),2)	return	endc	subroutine mark1(bitmap,n)	integer bitmap(1),n	data nbpw /31/        nword=(n-1)/nbpw	nbit=mod(n-1,nbpw)	i=2**(nbpw-nbit-1)	bitmap(nword+1)=bitmap(nword+1)+i*(1-mod(bitmap(nword+1)/i,2))	return	endc---------------End core contour routine--------------------------c---------------Color banded contouring---------------------------        subroutine gcnr2s(a,nx,ny)        dimension a(nx,ny),x(5),y(5),z(4)        logical clset        common /class/zcl(100),nrcl,clset,iop        save /class/        if(.not.clset) then            if(iop.eq.1) thenc      (percentiles-- not implemented)            else if(iop.eq.2) then              v1=vmin(a,nx*ny)              v2=vmax(a,nx*ny)              dz=(v2-v1)/float(nrcl+1)              do 3 i=1,nrcl3             zcl(i)=v1 + dz*float(i)              clset=.true.            endif        endif        call glimit(1.,float(nx),1.,float(ny),0.,0.)        call gscale        do 1 i=1,(nx-1)        do 1 j=1,(ny-1)        x(1)=float(i)        y(1)=float(j)        x(2)=float(i+1)        y(2)=float(j)        x(3)=float(i+1)        y(3)=float(j+1)        x(4)=float(i)        y(4)=float(j+1)        z(1)=a(i,j)        z(2)=a(i+1,j)        z(3)=a(i+1,j+1)        z(4)=a(i,j+1)1       call rrect4(x(1),y(1),x(3),y(3),z,0.)        call gwicol(1,3.)        call vframe        end