C-----------------------------------------------------------------------
      PROGRAM WINDEX1
C$$$  MAIN PROGRAM DOCUMENTATION BLOCK
C
C MAIN PROGRAM:  WINDEX1     WRITE AN INDEX FILE
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: PROGRAM CREATES AN INDEX FILE FROM A GRIB FILE.
C   THE INDEX FILE SERVES AS A TABLE OF CONTENTS FOR THE GRIB FILE,
C   ENABLING QUICK ACCESS TO THE DATA.  THE GRIB FILE MUST BE UNBLOCKED.
C   THE TWO FILE NAMES ARE RETRIEVED FROM THE COMMAND LINE ARGUMENTS.
C   THE FIRST ARGUMENT IS THE NAME OF THE INPUT GRIB FILE.
C   THE SECOND ARGUMENT IS THE NAME OF THE OUTPUT INDEX FILE.
C   CURRENTLY, ONLY VERSION 1 OF GRIB CAN BE READ.
C   VERSION 1 OF THE INDEX FILE HAS THE FOLLOWING FORMAT:
C     81-BYTE S.LORD HEADER WITH 'GB1IX1' IN COLUMNS 42-47 FOLLOWED BY
C     81-BYTE HEADER WITH NUMBER OF BYTES TO SKIP BEFORE INDEX RECORDS,
C     NUMBER OF BYTES IN EACH INDEX RECORD, NUMBER OF INDEX RECORDS,
C     AND GRIB FILE BASENAME WRITTEN IN FORMAT ('IX1FORM:',3I10,2X,A40).
C     EACH FOLLOWING INDEX RECORD CORRESPONDS TO A GRIB MESSAGE
C     AND HAS THE INTERNAL FORMAT:
C       BYTE 001-004: BYTES TO SKIP IN DATA FILE BEFORE GRIB MESSAGE
C       BYTE 005-008: BYTES TO SKIP IN MESSAGE BEFORE PDS
C       BYTE 009-012: BYTES TO SKIP IN MESSAGE BEFORE GDS (0 IF NO GDS)
C       BYTE 013-016: BYTES TO SKIP IN MESSAGE BEFORE BMS (0 IF NO BMS)
C       BYTE 017-020: BYTES TO SKIP IN MESSAGE BEFORE BDS
C       BYTE 021-024: BYTES TOTAL IN THE MESSAGE
C       BYTE 025-025: GRIB VERSION NUMBER
C       BYTE 026-053: PRODUCT DEFINITION SECTION (PDS)
C       BYTE 054-095: GRID DEFINITION SECTION (GDS) (OR NULLS)
C       BYTE 096-101: FIRST PART OF THE BIT MAP SECTION (BMS) (OR NULLS)
C       BYTE 102-112: FIRST PART OF THE BINARY DATA SECTION (BDS)
C
C PROGRAM HISTORY LOG:
C   92-11-22  IREDELL
C
C INPUT FILE:
C   ARG.   1     GRIB 1 FILE
C
C OUTPUT FILE:
C   ARG.   2     INDEX 1 FILE
C
C SUBPROGRAMS CALLED:
C   IARGC        COUNT THE COMMAND LINE ARGUMENTS
C   GETARG       GET COMMAND LINE ARGUMENT
C   ASNUNIT      ASSIGN FILE
C   FILENV       SET UNIQUE ENVIRONMENT VARIABLE
C   SKGB         SEEK NEXT GRIB MESSAGE
C   NCBASE       GET BASENAME OF FILE
C   WRGI1H       WRITE INDEX HEADERS
C   WRGI1R       WRITE INDEX RECORD
C   EXIT         EXIT WITH RETURN CODE
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      PARAMETER(MSEEK=4000)
      CHARACTER CGB1*256,CIX1*256
      INTEGER GETARG
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  CHECK NUMBER OF ARGUMENTS
      NARG=IARGC()
      IF(NARG.NE.2) THEN
        WRITE(0,*) 'WINDEX1:  ',
     &  'INCORRECT USAGE; EXACTLY TWO ARGUMENTS REQUIRED'
        CALL EXIT(2)
      ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  GET AND CHECK FIRST ARGUMENT (GRIB FILE NAME)
      NCGB1=GETARG(1,CGB1)
      IRET=ISHELL('test -s '//CGB1//'-a -r '//CGB1)
      IF(IRET.NE.0) THEN
        WRITE(0,*) 'WINDEX1:  ',
     &  CGB1(1:NCGB1),' DOES NOT EXIST OR CANNOT BE READ'
        CALL EXIT(IRET)
      ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  GET AND CHECK SECOND ARGUMENT (INDEX FILE NAME)
      NCIX1=GETARG(2,CIX1)
      IRET=ISHELL('> '//CIX1//' 2>/dev/null')
      IF(IRET.NE.0) THEN
        WRITE(0,*) 'WINDEX1:  ',
     &  CIX1(1:NCIX1),' CANNOT BE WRITTEN'
        CALL EXIT(IRET)
      ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  ASSIGN FILES
      CALL FILENV
      IRET=ISHELL('assign -a '//CGB1//' -sunblocked fort.11')
      IRET=ISHELL('assign -a '//CIX1//' -su fort.31')
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  SEARCH FOR FIRST GRIB MESSAGE
      ISEEK=0
      CALL SKGB(11,ISEEK,MSEEK,LSKIP,LGRIB)
      IF(LGRIB.EQ.0) THEN
        WRITE(0,*) 'WINDEX1:  ',
     &  'GRIB MESSAGE NOT FOUND WITHIN FIRST ',MSEEK,' BYTES'
        CALL EXIT(1)
      ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  WRITE FAKE HEADERS
      NCB=NCBASE(CGB1,NCGB1)
      NCD=NCBASE(CGB1,NCB-2)
      NGRIB=0
      CALL WRGI1H(31,NGRIB,CGB1(NCD:NCB-2),CGB1(NCB:NCGB1))
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  WRITE AN INDEX RECORD FOR EVERY GRIB RECORD FOUND
      DOWHILE(LGRIB.GT.0)
        NGRIB=NGRIB+1
        CALL WRGI1R(11,LSKIP,LGRIB,31)
        ISEEK=LSKIP+LGRIB
        CALL SKGB(11,ISEEK,MSEEK,LSKIP,LGRIB)
      ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  WRITE TRUE HEADERS
      CALL WRGI1H(31,NGRIB,CGB1(NCD:NCB-2),CGB1(NCB:NCGB1))
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END
C-----------------------------------------------------------------------
      SUBROUTINE SKGB(LUGB,ISEEK,MSEEK,LSKIP,LGRIB)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: SKGB           SEARCH FOR NEXT GRIB MESSAGE
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: THIS SUBPROGRAM SEARCHES A FILE FOR THE NEXT GRIB 1 MESSAGE.
C   A GRIB 1 MESSAGE IS IDENTIFIED BY ITS INDICATOR SECTION.
C
C PROGRAM HISTORY LOG:
C   93-11-22  IREDELL
C
C USAGE:    CALL SKGB(LUGB,ISEEK,MSEEK,LSKIP,LGRIB)
C   INPUT ARGUMENTS:
C     LUGB         INTEGER LOGICAL UNIT OF INPUT GRIB FILE
C     ISEEK        INTEGER NUMBER OF BYTES TO SKIP BEFORE SEARCH
C     MSEEK        INTEGER MAXIMUM NUMBER OF BYTES TO SEARCH
C   OUTPUT ARGUMENTS:
C     LSKIP        INTEGER NUMBER OF BYTES TO SKIP BEFORE MESSAGE
C     LGRIB        INTEGER NUMBER OF BYTES IN MESSAGE (0 IF NOT FOUND)
C
C SUBPROGRAMS CALLED:
C   BAREAD       BYTE-ADDRESSABLE READ
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      CHARACTER CSEEK(MSEEK),CSEEK4*4
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  READ SOME OF GRIB FILE INTO A BUFFER
      CALL BAREAD(LUGB,ISEEK,MSEEK,LSEEK,CSEEK)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  SEARCH BUFFER FOR AN 8-BYTE INDICATOR SECTION
C  IDENTIFIED BY 'GRIB' IN BYTES 1-4 AND 1 IN BYTE 8
      DO I=0,LSEEK-8
        CSEEK4=CSEEK(I+1)//CSEEK(I+2)//CSEEK(I+3)//CSEEK(I+4)
        IF(CSEEK4.EQ.'GRIB'.AND.ICHAR(CSEEK(I+8)).EQ.1) THEN
          LSKIP=ISEEK+I
          LGRIB=ICHAR(CSEEK(I+5))*65536
     &         +ICHAR(CSEEK(I+6))*256
     &         +ICHAR(CSEEK(I+7))
          RETURN
        ENDIF
      ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  GRIB MESSAGE NOT FOUND
      LSKIP=0
      LGRIB=0
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE WRGI1H(LUGI,NGRIB,CDNAME,CBNAME)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: WRGI1H         WRITE INDEX HEADERS
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: THIS SUBPROGRAM WRITES TWO INDEX HEADERS.
C   CURRENTLY, THE LENGTH OF EACH INDEX RECORD IS 112.
C
C PROGRAM HISTORY LOG:
C   93-11-22  IREDELL
C
C USAGE:    CALL WRGI1H(LUGI,NGRIB,CDNAME,CBNAME)
C   INPUT ARGUMENTS:
C     LUGI         INTEGER LOGICAL UNIT OF OUTPUT INDEX FILE
C     NGRIB        INTEGER NUMBER OF INDEX RECORDS
C     CDNAME       CHARACTER DIRECTORY NAME OF GRIB FILE
C                  (TO BE ENTERED IN BYTES 49-54 OF FIRST HEADER)
C     CBNAME       CHARACTER BASE NAME OF GRIB FILE
C                  (TO BE ENTERED IN BYTES 41-80 OF SECOND HEADER)
C
C SUBPROGRAMS CALLED:
C   DATE         GET CURRENT DATE
C   CLOCK        GET CURRENT TIME
C   UNAME        GET CURRENT SYSTEM NAME
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      PARAMETER(LINDEX=112)
      CHARACTER CDNAME*(*),CBNAME*(*)
      CHARACTER CDATE*8,CTIME*8,CSYS*8,CNODE*8,CREL*8,CVER*8,CMACH*8
      CHARACTER CHEAD(2)*81
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  GET DATE, TIME, AND SYSTEM NAME
      CALL DATE(CDATE)
      CALL CLOCK(CTIME)
      CALL UNAME(CSYS,CNODE,CREL,CVER,CMACH)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  FILL FIRST 81-BYTE HEADER
      CHEAD(1)='!GFHDR!'
      CHEAD(1)(9:10)=' 1'
      CHEAD(1)(12:14)='  1'
      WRITE(CHEAD(1)(16:20),'(I5)') 162
      CHEAD(1)(22:31)='19'//CDATE(7:8)//'-'//CDATE(1:2)//'-'//CDATE(4:5)
      CHEAD(1)(33:40)=CTIME(1:8)
      CHEAD(1)(42:47)='GB1IX1'
      CHEAD(1)(49:54)=CDNAME
      CHEAD(1)(56:70)=CSYS(1:7)//' '//CREL(1:7)
      CHEAD(1)(72:80)='WINDEX1  '
      CHEAD(1)(81:81)=CHAR(10)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  FILL SECOND 81-BYTE HEADER
      CHEAD(2)='IX1FORM:'
      WRITE(CHEAD(2)(9:38),'(3I10)') 162,LINDEX,NGRIB
      CHEAD(2)(41:80)=CBNAME
      CHEAD(2)(81:81)=CHAR(10)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  WRITE HEADERS AT BEGINNING OF INDEX FILE
      REWIND LUGI
      WRITE(LUGI) CHEAD
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE WRGI1R(LUGB,LSKIP,LGRIB,LUGI)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: WRGI1R         WRITE INDEX RECORD
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: THIS SUBPROGRAM WRITES ONE INDEX RECORD.
C   CURRENTLY, THE LENGTH OF EACH INDEX RECORD IS 112.
C
C PROGRAM HISTORY LOG:
C   93-11-22  IREDELL
C
C USAGE:    CALL WRGI1R(LUGB,LSKIP,LGRIB,LUGI)
C   INPUT ARGUMENTS:
C     LUGB         INTEGER LOGICAL UNIT OF INPUT GRIB FILE
C     LSKIP        INTEGER NUMBER OF BYTES TO SKIP BEFORE GRIB MESSAGE
C     LGRIB        INTEGER NUMBER OF BYTES IN GRIB MESSAGE
C     LUGI         INTEGER LOGICAL UNIT OF OUTPUT INDEX FILE
C
C SUBPROGRAMS CALLED:
C   GBYTE        GET INTEGER DATA FROM BYTES
C   SBYTE        STORE INTEGER DATA IN BYTES
C   BAREAD       BYTE-ADDRESSABLE READ
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      PARAMETER(LINDEX=112)
      PARAMETER(IXSKP=0,IXSPD=4,IXSGD=8,IXSBM=12,IXSBD=16,IXLEN=20,
     &          IXVER=24,IXPDS=25,IXGDS=53,IXBMS=95,IXBDS=101)
      PARAMETER(MXSKP=4,MXSPD=4,MXSGD=4,MXSBM=4,MXSBD=4,MXLEN=4,
     &          MXVER=1,MXPDS=28,MXGDS=42,MXBMS=6,MXBDS=11)
      CHARACTER GRIB(LGRIB),CINDEX(LINDEX)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  INITIALIZE INDEX RECORD AND READ GRIB MESSAGE
      CINDEX=CHAR(0)
      CALL SBYTE(CINDEX,LSKIP,8*IXSKP,8*MXSKP)
      CALL SBYTE(CINDEX,LGRIB,8*IXLEN,8*MXLEN)
      CALL BAREAD(LUGB,LSKIP,LGRIB,LREAD,GRIB)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  PUT PDS IN INDEX RECORD
      IF(LREAD.EQ.LGRIB) THEN
        CINDEX(IXVER+1)=GRIB(8)
        ISKPDS=8
        CALL SBYTE(CINDEX,ISKPDS,8*IXSPD,8*MXSPD)
        CALL GBYTE(GRIB,LENPDS,8*ISKPDS,8*3)
        CALL GBYTE(GRIB,INCGDS,8*ISKPDS+8*7+0,1)
        CALL GBYTE(GRIB,INCBMS,8*ISKPDS+8*7+1,1)
        ILNPDS=MIN(LENPDS,MXPDS)
        CINDEX(IXPDS+1:IXPDS+ILNPDS)=GRIB(ISKPDS+1:ISKPDS+ILNPDS)
        ISKTOT=ISKPDS+LENPDS
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  PUT GDS IN INDEX RECORD
        IF(INCGDS.NE.0) THEN
          ISKGDS=ISKTOT
          CALL SBYTE(CINDEX,ISKGDS,8*IXSGD,8*MXSGD)
          CALL GBYTE(GRIB,LENGDS,8*ISKGDS,8*3)
          ILNGDS=MIN(LENGDS,MXGDS)
          CINDEX(IXGDS+1:IXGDS+ILNGDS)=GRIB(ISKGDS+1:ISKGDS+ILNGDS)
          ISKTOT=ISKGDS+LENGDS
        ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  PUT BMS IN INDEX RECORD
        IF(INCBMS.NE.0) THEN
          ISKBMS=ISKTOT
          CALL SBYTE(CINDEX,ISKBMS,8*IXSBM,8*MXSBM)
          CALL GBYTE(GRIB,LENBMS,8*ISKBMS,8*3)
          ILNBMS=MIN(LENBMS,MXBMS)
          CINDEX(IXBMS+1:IXBMS+ILNBMS)=GRIB(ISKBMS+1:ISKBMS+ILNBMS)
          ISKTOT=ISKBMS+LENBMS
        ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  PUT BDS IN INDEX RECORD
        ISKBDS=ISKTOT
        CALL SBYTE(CINDEX,ISKBDS,8*IXSBD,8*MXSBD)
        CALL GBYTE(GRIB,LENBDS,8*ISKBDS,8*3)
        ILNBDS=MIN(LENBDS,MXBDS)
        CINDEX(IXBDS+1:IXBDS+ILNBDS)=GRIB(ISKBDS+1:ISKBDS+ILNBDS)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  WRITE INDEX RECORD
        WRITE(LUGI) CINDEX
      ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE FILENV
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: FILENV         SET UNIQUE FILENV ENVIRONMENT VARIABLE
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: THIS SUBPROGRAM SETS A UNIQUE FILENV ENVIRONMENT VARIABLE.
C   FILENV IS THE NAME OF THE FILE CONTAINING ASSIGN DATA.
C
C PROGRAM HISTORY LOG:
C   93-11-22  IREDELL
C
C USAGE:    CALL FILENV
C
C SUBPROGRAMS CALLED:
C   GETENV       GET ENVIRONMENT VARIABLE
C   GETPID       GET PROCESS ID
C   PUTENV       SET ENVIRONMENT VARIABLE
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      INTEGER GETENV,GETPID,PUTENV
      CHARACTER CTD*60,CPN*8
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  GET TEMPORARY DIRECTORY AND PROCESS ID
      IRET=GETENV('TMPDIR',CTD)
      NTD=0
      DOWHILE(CTD(NTD+1:NTD+1).NE.' ')
        NTD=NTD+1
      ENDDO
      IPN=GETPID()
      WRITE(CPN,'(I8)') IPN+10000000
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  BUILD UNIQUE FILE NAME AND SET FILENV
      IRET=PUTENV('FILENV='//CTD(1:NTD)//'/FILENV'//CPN(4:8))
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE BAREAD(LU,IB,NB,KA,A)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: BAREAD         BYTE-ADDRESSABLE READ
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: THIS SUBPROGRAM READS PART OF A FILE BY RANDOM ACCESS.
C   THE PART READ IS IDENTIFIED BY BYTE ADDRESSES.
C
C PROGRAM HISTORY LOG:
C   93-11-22  IREDELL
C
C USAGE:    CALL BAREAD(LU,IB,NB,KA,A)
C   INPUT ARGUMENTS:
C     LU           INTEGER LOGICAL UNIT OF FILE TO READ
C     IB           INTEGER NUMBER OF BYTES TO SKIP BEFORE READ
C     NB           INTEGER NUMBER OF BYTES TO READ
C     KA           INTEGER NUMBER OF BYTES ACTUALLY READ
C     A            REAL BUFFER READ
C
C SUBPROGRAMS CALLED:
C   SETPOS       SET POSITION IN FILE FOR RANDOM ACCESS
C   BUFFERIN     CRAY I/O EXTENSION
C   LENGTH       GET LENGTH OF RECORD READ
C   STRMOV       COPY BUFFER
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      CHARACTER A(NB)
      PARAMETER(NWK=512,NBW=8,NBK=NWK*NBW)
      DIMENSION B(NWK)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  FIND WORD TO START READ
      IW=IB/NBW
      NW=(IB+NB-1)/NBW+1-IB/NBW
      CALL SETPOS(LU,3,IW)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  READ FIRST BUFFER
      NWL=NW
      KA=0
      KB=IB-IW*NBW
      KW=MIN(NWL,NWK)
      BUFFERIN(LU,0) (B(1),B(KW))
      LW=LENGTH(LU)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  READ BUFFERS UNTIL DONE
      DOWHILE(NWL.GT.0.AND.LW.GT.0)
        KN=MIN(NB-KA,LW*NBW-KB)
        CALL STRMOV(B,KB+1,KN,A,KA+1)
        NWL=NWL-LW
        KA=KA+KN
        KB=0
        KW=MIN(NWL,NWK)
        BUFFERIN(LU,0) (B(1),B(KW))
        LW=LENGTH(LU)
      ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
C-----------------------------------------------------------------------
      FUNCTION NCBASE(C,N)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: NCBASE         LOCATE BASENAME OF A FILE
C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
C
C ABSTRACT: THIS SUBPROGRAM LOCATES THE CHARACTER NUMBER AFTER THE LAST /
C   IN A CHARACTER STRING.  FOR UNIX FILENAMES, THE CHARACTER NUMBER
C   RETURNED MARKS THE BEGINNING OF THE BASENAME OF THE FILE.
C
C PROGRAM HISTORY LOG:
C   93-11-22  IREDELL
C
C USAGE:     ...=NCBASE(C,N)
C   INPUT ARGUMENTS:
C     C            CHARACTER STRING TO SEARCH
C     N            INTEGER LENGTH OF STRING
C
C ATTRIBUTES:
C   LANGUAGE: CRAY FORTRAN
C
C$$$
      CHARACTER C*(*)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      K=N
      DOWHILE(K.GE.1.AND.C(K:K).NE.'/')
        K=K-1
      ENDDO
      NCBASE=K+1
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
